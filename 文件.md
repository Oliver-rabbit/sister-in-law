# IO基础
## 系统调用
### 系统调用的定义
作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有良好的兼容性。为了达到这个目的，内核提供一系列具备预定功能的函数接口即系统调用，呈现给用户。它是应用程序与操作系统间的接口与纽带，当用户访问系统调用，系统调用把应用程序的请求传递给内核，调用相应的内核函数完成所需处理，将处理结果返回给应用程序。
在没有任何库的支持下，原始的系统调用接口格式：
```c
_syscallX(type,name,type1,arg1,type2,arg2,...)
```
### 系统调用的优点
1. 为用户空间进程提供了访问内核的接口
2. 把用户从底层的硬件编程中解放出来：而无需了解底层设备的具体操作技术
3. 极大的提高了系统的安全性：所有对硬件设备资源的访问都需要通过系统调用，保护系统稳定可靠，防止应用程序恣意妄为。
### 系统调用的不足
1. 不同操作系统系统调用不兼容，程序移植工作量大。
2. 系统调用接口功能简单单一（每个系统调用都应该有一个明确的用途，Linux中不提倡采用多用途的系统调用）无法满足复杂程序的要求。

# 文件IO
## 文件的分类

| 类型     | 符号标识 | 描述                           |
| :----- | :--: | :--------------------------- |
| 普通文件   |  -   | 包含文本、二进制数据、图片、视频等            |
| 目录文件   |  d   | 存储文件名和文件信息的文件，可以包含其他文件和子目录   |
| 符号链接文件 |  l   | 指向另一个文件或目录的快捷方式              |
| 字符设备文件 |  c   | 提供串行访问的设备，数据以字符流形式传输（如键盘、终端） |
| 块设备文件  |  b   | 提供随机访问的设备，数据以块形式传输（如硬盘、U盘）   |
| 管道文件   |  p   | 用于进程间通信（IPC），一个进程写入，另一个进程读取  |
| 套接字文件  |  s   | 用于网络通信或进程间通信，支持双向数据流         |
## 文件描述符
文件描述符（File Descriptor，简称fd）是一个非负整数，是操作系统内核用来标识和管理已打开文件的抽象概念。是进程级的，每个进程有自己独立的文件描述符表。它是一个索引，指向内核维护的系统级文件表。
### 文件描述符简介
1. 文件描述符是文件IO的的操作对象
2. 文件描述符是一非负的整数，内核以此来标识一个特定进程已打开的文件。每当打开一个现存文件或创建一个新文件时，内核将向进程返回一个文件描述符，当对文件进行相应操作的时候，使用文件描述符作为参数传递给相应的函数
3. 文件描述符分配原则：<mark style="background: #FF5582A6;">顺序分配，最小可用</mark>
4. 通常一个进程启动时，都会打开三个文件：标准输入、标准输出、标准错误输出，这三个文件的文件描述符分别是0、1、2，对应的宏定义是STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO。可以查看头文件unistd.h查看相关定义。
<mark style="background: #FFB8EBA6;">文件描述符它的作用域是整个进程，当进程结束会自动释放已打开的文件描述符</mark>
范围：通常从0开始，最大值为系统限制（可通过`ulimit -n`查看）
### 文件描述符与文件的关系表
|层次|名称|说明|
|---|---|---|
|进程级|文件描述符表|每个进程独有，存放指向文件表项的指针。|
|系统级|文件表|系统全局，包含文件状态、当前偏移量等。|
|系统级|inode表|文件系统级，包含文件元数据（如权限、大小等）。|
### 常用操作函数表
| 函数           | 头文件              | 功能             | 返回值                 | 示例                                 |
| ------------ | ---------------- | -------------- | ------------------- | ---------------------------------- |
| **open()**   | `<fcntl.h>`      | 打开/创建文件        | 成功：新的fd  <br>失败：-1  | `fd = open("file.txt", O_RDONLY);` |
| **close()**  | `<unistd.h>`     | 关闭fd           | 成功：0  <br>失败：-1     | `close(fd);`                       |
| **read()**   | `<unistd.h>`     | 从fd读取数据        | 成功：读取字节数  <br>失败：-1 | `n = read(fd, buf, 1024);`         |
| **write()**  | `<unistd.h>`     | 向fd写入数据        | 成功：写入字节数  <br>失败：-1 | `n = write(fd, "hello", 5);`       |
| **dup()**    | `<unistd.h>`     | 复制fd           | 成功：新的fd             | `new_fd = dup(old_fd);`            |
| **dup2()**   | `<unistd.h>`     | 复制fd到指定值       | 成功：指定的fd            | `dup2(old_fd, 1);` # 重定向到stdout    |
| **fcntl()**  | `<fcntl.h>`      | 控制fd属性         | 取决于操作               | `fcntl(fd, F_SETFL, O_NONBLOCK);`  |
| **lseek()**  | `<unistd.h>`     | 移动文件偏移         | 成功：新偏移  <br>失败：-1   | `lseek(fd, 0, SEEK_SET);` # 移动到开头  |
| **select()** | `<sys/select.h>` | 多路复用等待fd就绪     | 成功：就绪fd数            | 监控多个fd的I/O状态                       |
| **poll()**   | `<poll.h>`       | 多路复用（改进select） | 成功：就绪fd数            | 无数量限制，效率更高                         |
### 文件描述符状态标志表
|标志类型|标志名|含义|设置方式|
|---|---|---|---|
|**访问模式**|O_RDONLY|只读|open()时指定|
||O_WRONLY|只写|open()时指定|
||O_RDWR|读写|open()时指定|
|**创建/打开**|O_CREAT|文件不存在则创建|open()时指定|
||O_EXCL|与O_CREAT同用，文件存在则失败|open()时指定|
||O_TRUNC|打开时清空文件|open()时指定|
||O_APPEND|追加模式（写操作总在末尾）|open()时指定或fcntl()设置|
|**同步/异步**|O_SYNC|写操作等待物理写入完成|open()时指定|
||O_ASYNC|启用信号驱动I/O|fcntl()设置|
|**非阻塞**|O_NONBLOCK|非阻塞I/O（立即返回）|open()时指定或fcntl()设置|
|**执行时关闭**|FD_CLOEXEC|exec()时自动关闭|open()时O_CLOEXEC或fcntl()设置|
### 查看和管理文件描述符的命令表
| 命令                       | 功能               | 示例                         |
| ------------------------ | ---------------- | -------------------------- |
| `ls -l /proc/<PID>/fd`   | 查看进程打开的所有fd      | `ls -l /proc/1234/fd`      |
| `lsof -p <PID>`          | 详细列出进程打开的文件      | `lsof -p 1234`             |
| `lsof -u <用户>`           | 查看用户打开的文件        | `lsof -u alice`            |
| `ss -tulnp`              | 查看socket相关的fd    | 显示所有网络连接                   |
| `cat /proc/<PID>/limits` | 查看进程限制（包括最大fd数）  | `cat /proc/1234/limits`    |
| `ulimit -n`              | 查看/设置shell的最大fd数 | `ulimit -n 1024` # 设置为1024 |
### 重要特性与限制表
| 特性    | 说明                                                                                  |
| ----- | ----------------------------------------------------------------------------------- |
| 继承性   | 子进程继承父进程的fd表（fork()后），但可设置FD_CLOEXEC避免继承                                            |
| 共享性   | 同一文件可被多个fd指向（同一进程或不同进程）                                                             |
| 引用计数  | 文件表项有引用计数，所有指向它的fd关闭后，文件才真正关闭                                                       |
| 最大数量  | 系统级限制：`cat /proc/sys/fs/file-max`  <br>用户级限制：`ulimit -n`  <br>进程级限制：通过getrlimit()获取 |
| 分配规则  | 总是分配当前最小的可用整数（如关闭fd 3后，下次open可能返回3）                                                 |
| 特殊值-1 | 表示无效的fd，很多系统调用对-1有特殊处理                                                              |
### 常见问题与解决方案表
|问题|原因|解决方案|
|---|---|---|
|**EMFILE (Too many open files)**|进程打开文件数超过限制|1. 检查代码是否及时close()  <br>2. 使用`ulimit -n`增大限制  <br>3. 使用`lsof`查找泄漏|
|**EBADF (Bad file descriptor)**|使用已关闭的fd|1. 确保fd有效后再使用  <br>2. 避免fd被意外关闭|
|**文件偏移共享**|dup()的fd共享偏移量|需要独立偏移时使用open()重新打开|
|**阻塞I/O卡住**|默认是阻塞模式|对于网络编程，设置O_NONBLOCK|
|**exec()后fd保持打开**|默认继承父进程fd|设置FD_CLOEXEC标志|
### 编程最佳实践表
|实践|理由|
|---|---|
|**打开后立即检查返回值**|避免使用无效的fd（-1）|
|**错误处理中关闭fd**|防止资源泄漏|
|**使用O_CLOEXEC标志**|防止exec()后意外继承fd|
|**循环中注意close()**|特别是服务器循环accept时|
|**注意fd的线程安全性**|fd在进程内共享，多线程操作需同步|
|**使用getrlimit()查询限制**|编写健壮的程序|
这个表格全面涵盖了文件描述符的核心概念、操作方法和实际应用，是理解Linux I/O机制的关键。
## 文件IO常用函数介绍
### `open`和`openat`函数
作用：打开文件
```c
	#include<fcntl.h>
	int open(const char* path,int oflag,.../*mode_t mode*/);
	int openat(int fd,const char*path,int oflag,.../*mode_t mode */);
```
- **参数**：
  - `path`：要打开或者创建文件的名字
  - `oflag`：用于指定函数的操作行为：
    - **以下五个常量中必须指定且只能指定一个**：
      - `O_RDONLY`：文件只读打开
      - `O_WRONLY`：文件只写打开
      - `O_RDWR`：文件读、写打开
      - `O_EXEC`：只执行打开
      - `O_SEARCH`：只搜索打开（应用于目录）。本文涉及的操作系统都没有支持该常量
    
    - **以下常量是可选的（进行或运算）**：
      - `O_APPEND`：每次写时都追加到文件的尾端
      - `O_CLOEXEC`：将`FD_CLOEXEC`常量设置为文件描述符标志
      - `O_CREAT`：若此文件不存在则创建它。在使用此选项时，需要同时说明参数`mode`（指定该文件的访问权限）
      - `O_DIRECTORY`：若`path`引用的不是目录，则出错
      - `O_EXCL`：若同时指定了`O_CREAT`时，且文件已存在则出错。根据此可以测试一个文件是否存在。若不存在则创建此文件。这使得测试和创建两者成为一个原子操作
      - `O_NOCTTY`：若`path`引用的是终端设备，则不将该设备分配作为此进程的控制终端
      - `O_NOFOLLOW`：若`path`引用的是一个符号链接，则出错
      - `O_NONBLOCK`：如果`path`引用的是一个`FIFO`、一个块特殊文件或者一个字符特殊文件，则文件本次打开操作和后续的 I/O 操作设为非阻塞模式。
      - `O_SYNC`：每次 `write` 等待物理 I/O 完成，包括由 `write` 操作引起的文件属性更新所需的 I/O 
      - `O_TRUNC`：如果此文件存在，且为`O_WRONLY`或者`O_RDWR`成功打开，则将其长度截断为0
      - `O_RSYNC`：使每一个`read`操作等待，直到所有对文件同一部分挂起的写操作都完成。
      - `O_DSYNC`：每次 `write` 等待物理 I/O 完成，但不包括由 `write` 操作引起的文件属性更新所需的 I/O 

  - `mode`：文件访问权限。文件访问权限常量在 `<sys/stat.h>` 中定义，有下列九个：
    - `S_IRUSR`：用户读
    - `S_IWUSR`：用户写
    - `S_IXUSR`：用户执行
    - `S_IRGRP`：组读
    - `S_IWGRP`：组写			
    - `S_IXGRP`：组执行			
    - `S_IROTH`：其他读
    - `S_IWOTH`：其他写
    - `S_IXOTH`：其他执行

- **对于`openat`函数**，被打开的文件名由`fd`和`path`共同决定：
  - 如果`path`指定的是绝对路径，此时`fd`被忽略。`openat`等价于`open`
  - 如果`path`指定的是相对路径名，则`fd`是一个目录打开的文件描述符。被打开的文件的绝对路径由该`fd`描述符对应的目录加上`path`组合而成
  - 如果`path`是一个相对路径名，而`fd`是常量`AT_FDCWD`，则`path`相对于当前工作目录。被打开文件在当前工作目录中查找。

- **返回值**：	
  - 成功：返回文件描述符
  - 失败：返回 -1

由 `open/openat` 返回的文件描述符一定是最小的未使用的描述符数字。
### `creat`函数
作用：创建一个新文件
```c
	#include<fcntl.h>
	int creat(const char*path,mode_t mode);
```
 - 参数：
		`path`:要创建文件的名字
		`mode`：指定该文件的访问权限文件访问权限常量在 `<sys/stat.h>` 中定义，有下列九个：
			`S_IRUSR`：用户读
			`S_IWUSR`：用户写
			`S_IXUSR`：用户执行
			`S_IRGRP`：组读
			`S_IWGRP`：组写			 
			`S_IXGRP`：组执行			
			`S_IROTH`：其他读
			`S_IWOTH`：其他写
			`S_IXOTH`：其他执行  
- 返回值：
		成功： 返回`O_WRONLY`打开的文件描述符
		失败： 返回 -1

	该函数等价于`open(path,O_WRONLY|O_CREAT|O_TRUNC,mode)`。注意：
	- 它以只写方式打开，因此若要读取该文件，则必须先关闭，然后重新以读方式打开。
	- 若文件已存在则将文件截断为0。
 